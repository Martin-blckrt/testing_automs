name: Issue → Slack (labels & status)

on:
  issues:
    types: [opened, labeled, unlabeled]

jobs:
  notify:
    runs-on: ubuntu-latest
    permissions:
      issues: read
    env:
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      REPO: ${{ github.repository }}
      EVENT_JSON: ${{ toJson(github.event) }}
      # === Configurable ===
      BUG_LABEL: "bug"              # label qui déclenche l’alerte « bug créé »
      STATUS_PREFIX: "status:"      # préfixe des labels de status (ex: "status: triage", "status: in progress", …)
    steps:
      - name: Common fields
        id: base
        run: |
          TITLE=$(jq -r '.issue.title' <<<"$EVENT_JSON")
          URL=$(jq -r '.issue.html_url' <<<"$EVENT_JSON")
          AUTHOR=$(jq -r '.issue.user.login' <<<"$EVENT_JSON")
          LABELS=$(jq -r '[.issue.labels[].name] | join(", ")' <<<"$EVENT_JSON")
          BODY=$(jq -r '.issue.body // ""' <<<"$EVENT_JSON" | head -c 700)

          echo "title=$TITLE"  >> $GITHUB_OUTPUT
          echo "url=$URL"      >> $GITHUB_OUTPUT
          echo "author=$AUTHOR">> $GITHUB_OUTPUT
          echo "labels=$LABELS">> $GITHUB_OUTPUT
          # corps tronqué pour Slack
          printf '%s' "$BODY" | sed ':a;N;$!ba;s/\r//g' > body.txt

      # (1) — Envoi quand un label précis vient d’être posé (ex: "bug")
      - name: Guard → newly labeled BUG
        id: bug_guard
        run: |
          ACTION=$(jq -r '.action' <<<"$EVENT_JSON")
          ADDED_LABEL=$(jq -r '.label.name // ""' <<<"$EVENT_JSON")
          if [ "$ACTION" = "labeled" ] && [ "$ADDED_LABEL" = "$BUG_LABEL" ]; then
            echo "send=yes" >> $GITHUB_OUTPUT
          else
            echo "send=no" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack → New BUG
        if: steps.bug_guard.outputs.send == 'yes'
        run: |
          jq -n \
            --arg repo "$REPO" \
            --arg title "${{ steps.base.outputs.title }}" \
            --arg url   "${{ steps.base.outputs.url }}" \
            --arg author "${{ steps.base.outputs.author }}" \
            --arg labels "${{ steps.base.outputs.labels }}" \
            --arg body "$(cat body.txt)" \
            '{
              text: "Nouvelle BUG REQUEST",
              blocks: [
                { "type":"section", "text":{"type":"mrkdwn", "text":":beetle: *Nouvelle BUG REQUEST*"} },
                { "type":"section", "text":{"type":"mrkdwn", "text":"*Repo:* `\($repo)`\n*Titre:* <\($url)|\($title)>\n*Auteur:* \($author)\n*Labels:* \($labels)"} },
                { "type":"section", "text":{"type":"mrkdwn", "text":"*Description:*\n```\($body)```"} }
              ]
            }' \
          | curl -s -X POST -H 'Content-type: application/json' --data @- "$SLACK_WEBHOOK_URL" -o /dev/stderr -w "HTTP %{http_code}\n"

      # (2) — Envoi quand le "status" change (labels de la famille STATUS_PREFIX)
      - name: Guard → status label event
        id: status_guard
        run: |
          ACTION=$(jq -r '.action' <<<"$EVENT_JSON")
          CHANGED_LABEL=$(jq -r '.label.name // ""' <<<"$EVENT_JSON")

          if [ "$ACTION" != "labeled" ] && [ "$ACTION" != "unlabeled" ]; then
            echo "send=no" >> $GITHUB_OUTPUT
            exit 0
          fi

          case "$CHANGED_LABEL" in
            "$STATUS_PREFIX"*) echo "is_status=yes"  >> $GITHUB_OUTPUT ;;
            *)                 echo "is_status=no"   >> $GITHUB_OUTPUT ;;
          esac

          echo "action=$ACTION"         >> $GITHUB_OUTPUT
          echo "changed=$CHANGED_LABEL" >> $GITHUB_OUTPUT

          if [ "$ACTION" = "labeled" ]; then
            # Status après ajout = label ajouté
            NEW_STATUS="$CHANGED_LABEL"
            # Essaye d’identifier l’éventuel ancien status encore présent
            OLD_STATUS=$(jq -r --arg pref "$STATUS_PREFIX" --arg now "$CHANGED_LABEL" \
              '[.issue.labels[].name | select(startswith($pref)) | select(. != $now)][0] // ""' <<<"$EVENT_JSON")
          else
            # ACTION = unlabeled
            OLD_STATUS="$CHANGED_LABEL"
            # Après retrait, le "nouveau" status est le premier autre label de la famille encore présent
            NEW_STATUS=$(jq -r --arg pref "$STATUS_PREFIX" \
              '[.issue.labels[].name | select(startswith($pref))][0] // ""' <<<"$EVENT_JSON")
          fi

          echo "old=$OLD_STATUS" >> $GITHUB_OUTPUT
          echo "new=$NEW_STATUS" >> $GITHUB_OUTPUT

          # On envoie si le label touché est un status ET s’il y a un changement concret
          if [ "$(echo $OLD_STATUS)" != "$(echo $NEW_STATUS)" ] && [ "${CHANGED_LABEL#"$STATUS_PREFIX"}" != "$CHANGED_LABEL" ]; then
            echo "send=yes" >> $GITHUB_OUTPUT
          else
            echo "send=no"  >> $GITHUB_OUTPUT
          fi

      - name: Send Slack → Status changed
        if: steps.status_guard.outputs.send == 'yes' && steps.status_guard.outputs.is_status == 'yes'
        run: |
          OLD="${{ steps.status_guard.outputs.old }}"
          NEW="${{ steps.status_guard.outputs.new }}"
          # Fallbacks lisibles
          [ -z "$OLD" ] && OLD="(aucun)"
          [ -z "$NEW" ] && NEW="(aucun)"

          jq -n \
            --arg repo "$REPO" \
            --arg title "${{ steps.base.outputs.title }}" \
            --arg url   "${{ steps.base.outputs.url }}" \
            --arg author "${{ steps.base.outputs.author }}" \
            --arg labels "${{ steps.base.outputs.labels }}" \
            --arg old "$OLD" \
            --arg new "$NEW" \
            '{
              text: "Changement de status sur une issue",
              blocks: [
                { "type":"section", "text":{"type":"mrkdwn", "text":":twisted_rightwards_arrows: *Status mis à jour*"} },
                { "type":"section", "text":{"type":"mrkdwn", "text":"*Repo:* `\($repo)`\n*Titre:* <\($url)|\($title)>\n*Auteur:* \($author)\n*Labels:* \($labels)"} },
                { "type":"section", "fields": [
                    { "type": "mrkdwn", "text": "*Ancien status:*\n`\($old)`" },
                    { "type": "mrkdwn", "text": "*Nouveau status:*\n`\($new)`" }
                  ]
                }
              ]
            }' \
          | curl -s -X POST -H 'Content-type: application/json' --data @- "$SLACK_WEBHOOK_URL" -o /dev/stderr -w "HTTP %{http_code}\n"
