name: Ticketing — Email depuis Issues

on:
  issues:
    types: [opened, edited, closed, reopened, labeled, unlabeled, assigned, unassigned]
  issue_comment:
    types: [created] # ajoute 'edited' si tu veux aussi sur édition

jobs:
  mail:
    runs-on: ubuntu-latest

    steps:
      # --------- Parse "mail:" / "objet:" puis corps ----------
      - name: Parse comment (mail/objet)
        if: ${{ github.event_name == 'issue_comment' }}
        id: filter
        uses: actions/github-script@v7
        with:
          script: |
            const raw = context.payload.comment?.body || "";
            const lines = raw.split(/\r?\n/);

            // Cherche les directives "mail:" et "objet:" dans les ~10 premières lignes non vides
            let mailLineIdx = -1, objetLineIdx = -1;
            for (let i = 0; i < Math.min(lines.length, 10); i++) {
              const t = lines[i].trim();
              if (!t) continue;
              if (mailLineIdx === -1 && /^mail\s*:/i.test(t)) { mailLineIdx = i; continue; }
              if (objetLineIdx === -1 && /^(objet|sujet|subject)\s*:/i.test(t)) { objetLineIdx = i; continue; }
              if (mailLineIdx !== -1 || objetLineIdx !== -1) break;
            }

            if (mailLineIdx === -1) {
              core.setOutput('send', 'false');
              core.info('Aucune ligne "mail:" trouvée → pas d\'envoi.');
              return;
            }

            const getVal = (line) =>
              line.split(/:/).slice(1).join(':').trim().replace(/^["'](.*)["']$/, '$1');

            const destRaw = getVal(lines[mailLineIdx] || "");
            const subjectRaw = objetLineIdx !== -1 ? getVal(lines[objetLineIdx] || "") : "";

            // Corps = tout après la dernière directive (mail/objet)
            const startBody = Math.max(mailLineIdx, objetLineIdx) + 1;
            const body = lines.slice(startBody).join('\n').trim() || '(pas de contenu)';

            // Parse des emails (séparés par virgule, point-virgule ou espace)
            const splitEmails = (s) => s.split(/[,\s;]+/).map(x => x.trim()).filter(Boolean);
            const emailRe = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            const to = Array.from(new Set(splitEmails(destRaw).filter(e => emailRe.test(e))));

            if (!to.length) {
              core.setOutput('send', 'false');
              core.info('Aucun destinataire valide dans "mail:" → pas d\'envoi.');
              return;
            }

            const iss = context.payload.issue;
            const actor = context.actor;
            const defaultSubject = `[Ticket #${iss?.number}] Commentaire par @${actor}`;

            core.setOutput('send', 'true');
            core.setOutput('to', to.join(','));
            core.setOutput('subject', subjectRaw || defaultSubject);
            core.setOutput('body', body);

      # --------- Envoi si directive valide ----------
      - name: Send email (issue_comment event)
        if: ${{ github.event_name == 'issue_comment' && steps.filter.outputs.send == 'true' }}
        uses: dawidd6/action-send-mail@v6
        with:
          server_address: ${{ secrets.SMTP_SERVER }}
          server_port: ${{ secrets.SMTP_PORT }}
          secure: ${{ secrets.SMTP_PORT == '465' }}   # ou force true/false selon ton port
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}

          from: "Ticket Bot <${{ secrets.SMTP_USERNAME }}>"
          to: ${{ steps.filter.outputs.to }}
          reply_to: "support+issue-${{ github.event.issue.number }}@tondomaine.com"

          subject: ${{ steps.filter.outputs.subject }}
          html_body: |

            ${{ steps.filter.outputs.body }}
          convert_markdown: true
